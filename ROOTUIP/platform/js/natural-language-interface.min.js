class NaturalLanguageInterface{constructor(){this.queryProcessor=new QueryProcessor,this.intentClassifier=new IntentClassifier,this.entityExtractor=new NLPEntityExtractor,this.responseGenerator=new ResponseGenerator,this.conversationManager=new ConversationManager,this.knowledgeBase=new KnowledgeBase,this.contextManager=new ContextManager,this.initialized=!1}async initialize(){console.log("Initializing Natural Language Interface..."),await Promise.all([this.queryProcessor.initialize(),this.intentClassifier.initialize(),this.entityExtractor.initialize(),this.responseGenerator.initialize(),this.conversationManager.initialize(),this.knowledgeBase.initialize(),this.contextManager.initialize()]),this.initialized=!0,console.log("Natural Language Interface initialized successfully")}async processQuery(e,t={}){if(!this.initialized)throw new Error("Natural Language Interface not initialized");const s=t.sessionId||this.generateSessionId();try{await this.conversationManager.addMessage(s,"user",e);const n=await this.queryProcessor.process(e,t),i=await this.intentClassifier.classify(n),a=await this.entityExtractor.extract(n,i),o=await this.contextManager.updateContext(s,{...t,intent:i,entities:a,query:n}),r=await this.generateResponse(i,a,o);return await this.conversationManager.addMessage(s,"assistant",r.text),{sessionId:s,intent:i.name,confidence:i.confidence,entities:a,response:r.text,data:r.data,suggestions:r.suggestions,followUpQuestions:r.followUpQuestions}}catch(t){console.error("Query processing failed:",t);return{sessionId:s,intent:"error",confidence:0,entities:[],response:await this.generateFallbackResponse(e,t),error:t.message}}}async generateResponse(e,t,s){switch(e.name){case"container_status":return await this.handleContainerStatusQuery(t,s);case"tracking_update":return await this.handleTrackingQuery(t,s);case"dd_risk_check":return await this.handleDDRiskQuery(t,s);case"cost_inquiry":return await this.handleCostInquiry(t,s);case"delay_prediction":return await this.handleDelayPrediction(t,s);case"document_status":return await this.handleDocumentStatus(t,s);case"port_congestion":return await this.handlePortCongestion(t,s);case"analytics_request":return await this.handleAnalyticsRequest(t,s);case"help_request":return await this.handleHelpRequest(t,s);default:return await this.handleGenericQuery(e,t,s)}}async handleContainerStatusQuery(e,t){const s=e.filter(e=>"CONTAINER_NUMBER"===e.type).map(e=>e.value);if(0===s.length)return{text:"I need a container number to check the status. Could you please provide the container number?",data:null,suggestions:["Try: 'What's the status of MSKU1234567?'"]};const n=await this.fetchContainerData(s[0]),i=this.formatContainerStatusResponse(n);return{text:i.text,data:n,suggestions:i.suggestions,followUpQuestions:["Would you like to see the full tracking history?","Should I check for any D&D risks?","Do you want predictions for delivery?"]}}async handleTrackingQuery(e,t){const s=e.filter(e=>"CONTAINER_NUMBER"===e.type).map(e=>e.value),n=e.filter(e=>"BL_NUMBER"===e.type).map(e=>e.value),i=s[0]||n[0];if(!i)return{text:"I need a container number or bill of lading number to provide tracking information.",suggestions:["Try: 'Track container MSKU1234567'","Try: 'Where is BL ABC123456?'"]};const a=await this.fetchTrackingData(i),o=this.formatTrackingResponse(a);return{text:o.text,data:a,suggestions:o.suggestions}}async handleDDRiskQuery(e,t){const s=e.filter(e=>"CONTAINER_NUMBER"===e.type).map(e=>e.value);if(0===s.length)return{text:"Which container would you like me to check for D&D risk?",suggestions:["Try: 'Check D&D risk for MSKU1234567'"]};const n=await this.getPredictiveAnalytics("dd_risk",{containerNumber:s[0]}),i=this.formatDDRiskResponse(n);return{text:i.text,data:n,suggestions:i.suggestions,followUpQuestions:["Would you like me to schedule a pickup?","Should I set up automated alerts for this container?"]}}async handleCostInquiry(e,t){const s=e.filter(e=>"LOCATION"===e.type||"PORT"===e.type).map(e=>e.value),n=e.filter(e=>"DESTINATION"===e.type).map(e=>e.value);if(0===s.length||0===n.length)return{text:"I need both origin and destination to provide cost information. Where are you shipping from and to?",suggestions:["Try: 'What's the cost from Shanghai to Los Angeles?'"]};const i=await this.getCostEstimate(s[0],n[0]),a=this.formatCostResponse(i);return{text:a.text,data:i,suggestions:a.suggestions}}async handleDelayPrediction(e,t){const s=e.filter(e=>"CONTAINER_NUMBER"===e.type).map(e=>e.value),n=e.filter(e=>"ROUTE"===e.type).map(e=>e.value),i=await this.getPredictiveAnalytics("container_delay",{containerNumber:s[0],route:n[0]}),a=this.formatDelayPredictionResponse(i);return{text:a.text,data:i,suggestions:a.suggestions}}async handleDocumentStatus(e,t){const s=e.filter(e=>"DOCUMENT_TYPE"===e.type).map(e=>e.value),n=e.filter(e=>"REFERENCE_NUMBER"===e.type).map(e=>e.value),i=await this.fetchDocumentStatus(n[0],s[0]),a=this.formatDocumentStatusResponse(i);return{text:a.text,data:i,suggestions:a.suggestions}}async handlePortCongestion(e,t){const s=e.filter(e=>"PORT"===e.type||"LOCATION"===e.type).map(e=>e.value);if(0===s.length)return{text:"Which port would you like me to check for congestion?",suggestions:["Try: 'What's the congestion at Los Angeles port?'"]};const n=await this.getPredictiveAnalytics("port_congestion",{portCode:s[0]}),i=this.formatPortCongestionResponse(n);return{text:i.text,data:n,suggestions:i.suggestions}}async handleAnalyticsRequest(e,t){const s=e.filter(e=>"METRIC"===e.type).map(e=>e.value),n=e.filter(e=>"TIMEFRAME"===e.type).map(e=>e.value),i=await this.getAnalyticsData(s[0],n[0]),a=this.formatAnalyticsResponse(i);return{text:a.text,data:i,suggestions:a.suggestions}}async handleHelpRequest(e,t){const s=e.filter(e=>"HELP_TOPIC"===e.type).map(e=>e.value),n=await this.knowledgeBase.getHelp(s[0]||"general");return{text:n.content,data:n,suggestions:n.relatedTopics,followUpQuestions:n.commonQuestions}}async handleGenericQuery(e,t,s){const n=await this.knowledgeBase.search(s.query);return n.confidence>.7?{text:n.answer,data:n,suggestions:n.relatedQuestions}:{text:"I'm not sure I understand that request. Could you please rephrase it or try asking about container status, tracking, costs, or delays?",suggestions:["Ask about container status","Check tracking information","Get cost estimates","View port congestion"]}}formatContainerStatusResponse(e){const t=e.status,s=e.currentLocation,n=e.eta;let i=`Container ${e.containerNumber} is currently ${t}`;if(s&&(i+=` at ${s}`),n){i+=`. Expected arrival: ${new Date(n).toLocaleDateString()}`}return{text:i,suggestions:["Check D&D risk","View full tracking history","Get delay predictions"]}}formatTrackingResponse(e){const t=(e.events||[])[0];let s=`Latest update for ${e.identifier}: `;s+=t?`${t.description} at ${t.location} on ${new Date(t.timestamp).toLocaleDateString()}`:"No tracking events found";return{text:s,suggestions:["Show all tracking events","Get delivery prediction","Check for delays"]}}formatDDRiskResponse(e){const t=e.riskLevel;let s=`D&D Risk Level: ${t} (${Math.round(100*e.riskScore)}% probability)`;"HIGH"!==t&&"CRITICAL"!==t||(s+=". ⚠️ Immediate action recommended!",e.recommendations&&e.recommendations.length>0&&(s+=` ${e.recommendations[0].description}`));return{text:s,suggestions:["Schedule pickup","Request free time extension","View mitigation options"]}}formatCostResponse(e){const t=e.estimatedCost;let s=`Estimated cost: ${e.currency||"USD"} ${t.toLocaleString()}`;e.breakdown&&(s+=` (Ocean freight: ${e.breakdown.oceanFreight}, Local charges: ${e.breakdown.localCharges})`),e.transitTime&&(s+=`. Transit time: ${e.transitTime} days`);return{text:s,suggestions:["Get cost breakdown","Compare carriers","Book shipment"]}}formatDelayPredictionResponse(e){const t=Math.round(100*e.delayProbability),s=e.expectedDelay;let n=`Delay probability: ${t}%`;s>0&&(n+=`. Expected delay: ${s} day${s>1?"s":""}`,e.delayReasons&&e.delayReasons.length>0&&(n+=`. Main reason: ${e.delayReasons[0].description}`));return{text:n,suggestions:["View mitigation options","Get alternative routes","Set up alerts"]}}formatPortCongestionResponse(e){const t=Math.round(100*e.congestionLevel);let s=`Port congestion: ${t}% (${e.trend})`;s+=t>80?". ⚠️ High congestion - consider alternative ports":t>60?". ⚠️ Moderate congestion - possible delays":". ✅ Normal operations";return{text:s,suggestions:["View alternative ports","Get congestion forecast","Check processing times"]}}formatAnalyticsResponse(e){const t=e.metric,s=e.value,n=e.change;let i=`${t}: ${s}`;if(n){i+=` (${n>0?`+${n}`:n}% vs previous period)`}return{text:i,suggestions:["View detailed breakdown","Export report","Set up alerts"]}}async generateFallbackResponse(e,t){const s=["I apologize, but I'm having trouble understanding that request. Could you please rephrase it?","I'm not sure about that. Try asking about container status, tracking, costs, or port information.","Let me help you with that. What specific information are you looking for?","I can help with container tracking, D&D risk assessment, cost estimates, and more. What would you like to know?"];return s[Math.floor(Math.random()*s.length)]}async fetchContainerData(e){return await this.sleep(200),{containerNumber:e,status:"In Transit",currentLocation:"Pacific Ocean",vessel:"Maersk Edinburg",eta:new Date(Date.now()+6048e5).toISOString(),origin:"Shanghai",destination:"Los Angeles"}}async fetchTrackingData(e){return await this.sleep(300),{identifier:e,events:[{timestamp:new Date(Date.now()-1728e5).toISOString(),description:"Departed",location:"Shanghai",status:"DEPARTED"},{timestamp:new Date(Date.now()-432e6).toISOString(),description:"Loaded",location:"Shanghai Terminal",status:"LOADED"}]}}async getPredictiveAnalytics(e,t){if(await this.sleep(500),"undefined"!=typeof window&&window.AIEngine)return await window.AIEngine.predictiveAnalytics.predict(e,t);switch(e){case"dd_risk":return{riskScore:.75,riskLevel:"HIGH",recommendations:[{description:"Schedule immediate pickup to avoid charges"}]};case"container_delay":return{delayProbability:.3,expectedDelay:1,delayReasons:[{description:"Port congestion at destination"}]};case"port_congestion":return{congestionLevel:.65,trend:"stable"};default:return{}}}async getCostEstimate(e,t){return await this.sleep(400),{estimatedCost:2500+1e3*Math.random(),currency:"USD",transitTime:14,breakdown:{oceanFreight:2e3,localCharges:500}}}async fetchDocumentStatus(e,t){return await this.sleep(200),{reference:e,type:t||"Bill of Lading",status:"Processed",confidence:.95}}async getAnalyticsData(e,t){return await this.sleep(300),{metric:e||"Total Savings",value:"$14.2M",change:23,timeframe:t||"YTD"}}generateSessionId(){return`session_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}sleep(e){return new Promise(t=>setTimeout(t,e))}}class QueryProcessor{async initialize(){console.log("Initializing Query Processor...")}async process(e,t){let s=e.toLowerCase().trim();return s=s.replace(/what's/g,"what is"),s=s.replace(/where's/g,"where is"),s=s.replace(/how's/g,"how is"),s=s.replace(/container\s*#?\s*([a-z]{4}\d{7})/gi,"container $1"),{original:e,processed:s,tokens:s.split(/\s+/),context:t}}}class IntentClassifier{constructor(){this.intents=new Map}async initialize(){console.log("Initializing Intent Classifier..."),this.intents.set("container_status",{patterns:[/status.*container/i,/where.*container/i,/container.*status/i,/check.*container/i],keywords:["status","where","location","container"]}),this.intents.set("tracking_update",{patterns:[/track/i,/tracking/i,/trace/i,/follow/i],keywords:["track","tracking","trace","follow","updates"]}),this.intents.set("dd_risk_check",{patterns:[/d&d/i,/demurrage/i,/detention/i,/risk/i],keywords:["dd","demurrage","detention","risk","charges"]}),this.intents.set("cost_inquiry",{patterns:[/cost/i,/price/i,/rate/i,/quote/i,/how much/i],keywords:["cost","price","rate","quote","much","expensive"]}),this.intents.set("delay_prediction",{patterns:[/delay/i,/late/i,/behind/i,/schedule/i],keywords:["delay","late","behind","schedule","time"]}),this.intents.set("help_request",{patterns:[/help/i,/how.*do/i,/what.*can/i,/assist/i],keywords:["help","how","what","can","assist","support"]})}async classify(e){const{processed:t,tokens:s}=e,n=new Map;for(const[e,i]of this.intents.entries()){let a=0;for(const e of i.patterns)e.test(t)&&(a+=.8);for(const e of i.keywords)s.includes(e.toLowerCase())&&(a+=.3);a>0&&n.set(e,a)}let i="unknown",a=0;for(const[e,t]of n.entries())t>a&&(i=e,a=t);return{name:i,confidence:Math.min(a,1),allScores:Object.fromEntries(n)}}}class NLPEntityExtractor{constructor(){this.patterns=new Map}async initialize(){console.log("Initializing NLP Entity Extractor..."),this.patterns.set("CONTAINER_NUMBER",/\b[A-Z]{4}\d{7}\b/gi),this.patterns.set("BL_NUMBER",/(?:bl|bill of lading)\s*#?\s*([A-Z0-9]+)/gi),this.patterns.set("PORT",/\b(?:port of |port )?([A-Z]{5}|[A-Z][a-z]+ [A-Z][a-z]+)\b/gi),this.patterns.set("DATE",/\b\d{1,2}[-\/]\d{1,2}[-\/]\d{2,4}\b/g),this.patterns.set("AMOUNT",/\$[\d,]+\.?\d*/g),this.patterns.set("PERCENTAGE",/\d+\.?\d*%/g)}async extract(e,t){const{processed:s}=e,n=[];for(const[e,t]of this.patterns.entries()){const i=[...s.matchAll(t)];for(const t of i)n.push({type:e,value:t[1]||t[0],startIndex:t.index,endIndex:t.index+t[0].length,confidence:.9})}return n.push(...this.extractIntentEntities(s,t)),n}extractIntentEntities(e,t){const s=[];switch(t.name){case"cost_inquiry":const t=e.match(/from\s+([a-z\s]+?)(?:\s+to|\s+$)/i),n=e.match(/to\s+([a-z\s]+?)(?:\s|$)/i);t&&s.push({type:"ORIGIN",value:t[1].trim(),confidence:.8}),n&&s.push({type:"DESTINATION",value:n[1].trim(),confidence:.8});break;case"analytics_request":const i=e.match(/(savings|cost|revenue|performance|efficiency)/i);i&&s.push({type:"METRIC",value:i[1],confidence:.85})}return s}}class ResponseGenerator{async initialize(){console.log("Initializing Response Generator...")}}class ConversationManager{constructor(){this.conversations=new Map}async initialize(){console.log("Initializing Conversation Manager...")}async addMessage(e,t,s){this.conversations.has(e)||this.conversations.set(e,[]),this.conversations.get(e).push({role:t,content:s,timestamp:new Date})}getConversation(e){return this.conversations.get(e)||[]}}class KnowledgeBase{constructor(){this.knowledge=new Map}async initialize(){console.log("Initializing Knowledge Base..."),this.knowledge.set("general",{content:"I can help you with container tracking, D&D risk assessment, cost estimates, delay predictions, and port information.",relatedTopics:["tracking","costs","delays","ports"],commonQuestions:["How do I track a container?","What is D&D risk?","How do I get cost estimates?"]})}async search(e){for(const[t,s]of this.knowledge.entries())if(e.toLowerCase().includes(t))return{answer:s.content,confidence:.8,relatedQuestions:s.commonQuestions};return{answer:"I don't have specific information about that.",confidence:.2,relatedQuestions:[]}}async getHelp(e){return this.knowledge.get(e)||this.knowledge.get("general")}}class ContextManager{constructor(){this.contexts=new Map}async initialize(){console.log("Initializing Context Manager...")}async updateContext(e,t){const s={...this.contexts.get(e)||{},...t};return this.contexts.set(e,s),s}getContext(e){return this.contexts.get(e)||{}}}"undefined"!=typeof module&&module.exports&&(module.exports={NaturalLanguageInterface:NaturalLanguageInterface,QueryProcessor:QueryProcessor,IntentClassifier:IntentClassifier,NLPEntityExtractor:NLPEntityExtractor,ResponseGenerator:ResponseGenerator,ConversationManager:ConversationManager,KnowledgeBase:KnowledgeBase,ContextManager:ContextManager});